{"ast":null,"code":"import sync from 'framesync';\nvar unresolvedJobs = new Set();\nvar layoutState = {\n  isMeasuringLayout: false\n};\n\nfunction pushJob(stack, job, pointer) {\n  if (!stack[pointer]) stack[pointer] = [];\n  stack[pointer].push(job);\n}\n\nfunction batchLayout(callback) {\n  unresolvedJobs.add(callback);\n  return function () {\n    return unresolvedJobs.delete(callback);\n  };\n}\n\nfunction flushLayout() {\n  if (!unresolvedJobs.size) return;\n  var pointer = 0;\n  var reads = [[]];\n  var writes = [];\n\n  var setRead = function (job) {\n    return pushJob(reads, job, pointer);\n  };\n\n  var setWrite = function (job) {\n    pushJob(writes, job, pointer);\n    pointer++;\n  };\n  /**\n   * Resolve jobs into their array stacks\n   */\n\n\n  unresolvedJobs.forEach(function (callback) {\n    callback(setRead, setWrite);\n    pointer = 0;\n  });\n  unresolvedJobs.clear();\n  /**\n   * Mark that we're currently measuring layouts. This allows us to, for instance, ignore\n   * hover events that might be triggered as a result of resetting transforms.\n   *\n   * The postRender/setTimeout combo seems like an odd bit of scheduling but what it's saying\n   * is *after* the next render, wait 10ms before re-enabling hover events. Waiting until the\n   * next frame completely will result in missed, valid hover events. But events seem to\n   * be fired async from their actual action, so setting this to false too soon can still\n   * trigger events from layout measurements.\n   *\n   * Note: If we figure out a way of measuring layout while transforms remain applied, this can be removed.\n   * I have attempted unregistering event listeners and setting CSS to pointer-events: none\n   * but neither seem to work as expected.\n   */\n\n  layoutState.isMeasuringLayout = true;\n  sync.postRender(function () {\n    setTimeout(function () {\n      return layoutState.isMeasuringLayout = false;\n    }, 10);\n  });\n  /**\n   * Execute jobs\n   */\n\n  var numStacks = writes.length;\n\n  for (var i = 0; i <= numStacks; i++) {\n    reads[i] && reads[i].forEach(executeJob);\n    writes[i] && writes[i].forEach(executeJob);\n  }\n}\n\nvar executeJob = function (job) {\n  return job();\n};\n\nexport { batchLayout, flushLayout, layoutState };","map":{"version":3,"sources":["/home/pmorim/ISEP/CONDIG/research/client/node_modules/framer-motion/dist/es/render/dom/utils/batch-layout.js"],"names":["sync","unresolvedJobs","Set","layoutState","isMeasuringLayout","pushJob","stack","job","pointer","push","batchLayout","callback","add","delete","flushLayout","size","reads","writes","setRead","setWrite","forEach","clear","postRender","setTimeout","numStacks","length","i","executeJob"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,WAAjB;AAEA,IAAIC,cAAc,GAAG,IAAIC,GAAJ,EAArB;AACA,IAAIC,WAAW,GAAG;AACdC,EAAAA,iBAAiB,EAAE;AADL,CAAlB;;AAGA,SAASC,OAAT,CAAiBC,KAAjB,EAAwBC,GAAxB,EAA6BC,OAA7B,EAAsC;AAClC,MAAI,CAACF,KAAK,CAACE,OAAD,CAAV,EACIF,KAAK,CAACE,OAAD,CAAL,GAAiB,EAAjB;AACJF,EAAAA,KAAK,CAACE,OAAD,CAAL,CAAeC,IAAf,CAAoBF,GAApB;AACH;;AACD,SAASG,WAAT,CAAqBC,QAArB,EAA+B;AAC3BV,EAAAA,cAAc,CAACW,GAAf,CAAmBD,QAAnB;AACA,SAAO,YAAY;AAAE,WAAOV,cAAc,CAACY,MAAf,CAAsBF,QAAtB,CAAP;AAAyC,GAA9D;AACH;;AACD,SAASG,WAAT,GAAuB;AACnB,MAAI,CAACb,cAAc,CAACc,IAApB,EACI;AACJ,MAAIP,OAAO,GAAG,CAAd;AACA,MAAIQ,KAAK,GAAG,CAAC,EAAD,CAAZ;AACA,MAAIC,MAAM,GAAG,EAAb;;AACA,MAAIC,OAAO,GAAG,UAAUX,GAAV,EAAe;AAAE,WAAOF,OAAO,CAACW,KAAD,EAAQT,GAAR,EAAaC,OAAb,CAAd;AAAsC,GAArE;;AACA,MAAIW,QAAQ,GAAG,UAAUZ,GAAV,EAAe;AAC1BF,IAAAA,OAAO,CAACY,MAAD,EAASV,GAAT,EAAcC,OAAd,CAAP;AACAA,IAAAA,OAAO;AACV,GAHD;AAIA;AACJ;AACA;;;AACIP,EAAAA,cAAc,CAACmB,OAAf,CAAuB,UAAUT,QAAV,EAAoB;AACvCA,IAAAA,QAAQ,CAACO,OAAD,EAAUC,QAAV,CAAR;AACAX,IAAAA,OAAO,GAAG,CAAV;AACH,GAHD;AAIAP,EAAAA,cAAc,CAACoB,KAAf;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACIlB,EAAAA,WAAW,CAACC,iBAAZ,GAAgC,IAAhC;AACAJ,EAAAA,IAAI,CAACsB,UAAL,CAAgB,YAAY;AACxBC,IAAAA,UAAU,CAAC,YAAY;AAAE,aAAQpB,WAAW,CAACC,iBAAZ,GAAgC,KAAxC;AAAiD,KAAhE,EAAkE,EAAlE,CAAV;AACH,GAFD;AAGA;AACJ;AACA;;AACI,MAAIoB,SAAS,GAAGP,MAAM,CAACQ,MAAvB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIF,SAArB,EAAgCE,CAAC,EAAjC,EAAqC;AACjCV,IAAAA,KAAK,CAACU,CAAD,CAAL,IAAYV,KAAK,CAACU,CAAD,CAAL,CAASN,OAAT,CAAiBO,UAAjB,CAAZ;AACAV,IAAAA,MAAM,CAACS,CAAD,CAAN,IAAaT,MAAM,CAACS,CAAD,CAAN,CAAUN,OAAV,CAAkBO,UAAlB,CAAb;AACH;AACJ;;AACD,IAAIA,UAAU,GAAG,UAAUpB,GAAV,EAAe;AAAE,SAAOA,GAAG,EAAV;AAAe,CAAjD;;AAEA,SAASG,WAAT,EAAsBI,WAAtB,EAAmCX,WAAnC","sourcesContent":["import sync from 'framesync';\n\nvar unresolvedJobs = new Set();\nvar layoutState = {\n    isMeasuringLayout: false,\n};\nfunction pushJob(stack, job, pointer) {\n    if (!stack[pointer])\n        stack[pointer] = [];\n    stack[pointer].push(job);\n}\nfunction batchLayout(callback) {\n    unresolvedJobs.add(callback);\n    return function () { return unresolvedJobs.delete(callback); };\n}\nfunction flushLayout() {\n    if (!unresolvedJobs.size)\n        return;\n    var pointer = 0;\n    var reads = [[]];\n    var writes = [];\n    var setRead = function (job) { return pushJob(reads, job, pointer); };\n    var setWrite = function (job) {\n        pushJob(writes, job, pointer);\n        pointer++;\n    };\n    /**\n     * Resolve jobs into their array stacks\n     */\n    unresolvedJobs.forEach(function (callback) {\n        callback(setRead, setWrite);\n        pointer = 0;\n    });\n    unresolvedJobs.clear();\n    /**\n     * Mark that we're currently measuring layouts. This allows us to, for instance, ignore\n     * hover events that might be triggered as a result of resetting transforms.\n     *\n     * The postRender/setTimeout combo seems like an odd bit of scheduling but what it's saying\n     * is *after* the next render, wait 10ms before re-enabling hover events. Waiting until the\n     * next frame completely will result in missed, valid hover events. But events seem to\n     * be fired async from their actual action, so setting this to false too soon can still\n     * trigger events from layout measurements.\n     *\n     * Note: If we figure out a way of measuring layout while transforms remain applied, this can be removed.\n     * I have attempted unregistering event listeners and setting CSS to pointer-events: none\n     * but neither seem to work as expected.\n     */\n    layoutState.isMeasuringLayout = true;\n    sync.postRender(function () {\n        setTimeout(function () { return (layoutState.isMeasuringLayout = false); }, 10);\n    });\n    /**\n     * Execute jobs\n     */\n    var numStacks = writes.length;\n    for (var i = 0; i <= numStacks; i++) {\n        reads[i] && reads[i].forEach(executeJob);\n        writes[i] && writes[i].forEach(executeJob);\n    }\n}\nvar executeJob = function (job) { return job(); };\n\nexport { batchLayout, flushLayout, layoutState };\n"]},"metadata":{},"sourceType":"module"}